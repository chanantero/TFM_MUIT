%% Simulation with different impulse responses generated by RIR-Generator-Master

%% Preamble
pathSetUp;

imagesPath = 'C:\Users\Rubén\Google Drive\Telecomunicación\Máster 2º Curso 2015-2016\TFM MUIT\Documentos\TFM\Img\';

dataPathName = [globalPath, 'Data\'];
ID = datestr(now, 'yyyy-mm-dd_HH-MM-SS');

%% Parameters
obj = SimulationController;

% Constants
c = 340; % Sound velocity (m/s)
fs = 44100; % Sample frequency (samples/s)
WFSarrayOffset = [0.5, 1.5, 1.5]; % [x, y, z] coordinates

% Noise source coefficient
obj.amplitude = 1;
obj.amplitude(2) = -obj.amplitude(1);
obj.phase = 0;

% Default values. They don't matter, but do not touch just in case.
obj.NSposition = [3.35 -0.2 0]; % Assumed real position
obj.frequency = 800;
obj.Fs = fs;

% Frequency filter for the time WFS filter
load('WFSTool/WFSfilter.mat')
obj.WFSToolObj.freqFilter = hTotal;

% Microphone positions
% Rectangular grid
marginRatio = 0.6;
numPointsX = 5;
numPoinstY = 5;
extRectXmin = min(obj.WFSposition(:, 1));
extRectXmax = max(obj.WFSposition(:, 1));
extRectYmin = min(obj.WFSposition(:, 2));
extRectYmax = max(obj.WFSposition(:, 2));
octagonRectPos = [extRectXmin, extRectYmin, extRectXmax - extRectXmin, extRectYmax - extRectYmin];
gridXLength = octagonRectPos(3)*marginRatio;
gridYLength = octagonRectPos(4)*marginRatio;
centerX = (extRectXmax + extRectXmin)/2;
centerY = (extRectYmax + extRectYmin)/2;
gridMinX = centerX - gridXLength/2;
gridMaxX = centerX + gridXLength/2;
gridMinY = centerY - gridYLength/2;
gridMaxY = centerY + gridYLength/2;
xLim = [gridMinX, gridMaxX ]; yLim = [gridMinY, gridMaxY];
x = linspace(xLim(1), xLim(2), numPointsX);
y = linspace(yLim(1), yLim(2), numPoinstY);
z = 0;
[X, Y, Z] = ndgrid(x, y, z);
recPositions = [X(:), Y(:), Z(:)];
numMicro = size(recPositions, 1);
obj.microPos = recPositions;

% Positions of the noise source
% Circles
numPointsPerCircle = 20;
radius = [5 50 5000];
numCircles = numel(radius);
alpha = linspace(0, 2*pi, numPointsPerCircle + 1); alpha = alpha(1:end-1)';
xOctagon = obj.WFSposition(:, 1);
yOctagon = obj.WFSposition(:, 2);
centreX = (max(xOctagon) + min(xOctagon))/2;
centreY = (max(yOctagon) + min(yOctagon))/2;
x = centreX + repmat(radius, numPointsPerCircle, 1).*repmat(cos(alpha), 1, numCircles);
y = centreY + repmat(radius, numPointsPerCircle, 1).*repmat(sin(alpha), 1, numCircles);
NSpositions = [x(:), y(:), zeros(numel(x), 1)];
numNSpos = size(NSpositions, 1);

% Frequencies
fAliasing = 340/0.36;
numFreqs = 10;
freqs = linspace(10, fAliasing, numFreqs);

%% Pre-calculate impulse responses
% Since it would take a lot of time to calculate the IR during the
% simulations, we calculate it previously and save it to a .mat. 

r = recPositions + repmat(WFSarrayOffset, numMicro, 1); % Receiver position [x y z] (m)
s = [3.35 -0.2 0];              % Source position [x y z] (m)
roomDim = [3 7 3];                % Room dimensions [x y z] (m)
numSamp = 4096;                   % Number of samples

% This is the variable that is going to change
numReverbTime = 1;
beta = linspace(0, 0.5, numReverbTime);                 % Reverberation time (s)

WFS_IR = zeros(obj.numMicro, numSamp, obj.numWFS, numReverbTime);
disp('IR WFS')
for k = 1:obj.numWFS
    fprintf('%d/%d\n', k, obj.numWFS);
    disp(' Reverberation Time:')
    for rt = 1:numReverbTime
        fprintf(' %d/%d\n', rt, numReverbTime);
        WFS_IR(:, :, k, rt) = rir_generator(c, fs, r, obj.WFSposition(k, :), roomDim, beta(rt), numSamp);
    end
end

% Calculate the frequency responses
WFS_RR = zeros(obj.numMicro, numFreqs, obj.numWFS, numReverbTime);
disp('FR WFS')
for k = 1:obj.numWFS
    fprintf('%d/%d\n', k, obj.numWFS);
    disp(' Reverberation Time:')
    for rt = 1:numReverbTime
        WFS_RR(:, :, k, rt) = DFT_slow(fs*WFS_IR(:, :, k, rt).', fs, freqs).'; % (numFrequencies x numLoudspeakers)
    end
end

save([dataPathName, 'ImpulseResponsesWFS_', ID, '.mat'], 'r', 'roomDim', 'numSamp', 'obj.WFSposition', 'freqs', 'WFS_IR', 'WFS_RR')

% Do the same with the noise source positions
NS_IR = zeros(obj.numMicro, numSamp, numNSpos, numReverbTime);
disp('IR NS')
for k = 1:numNSpos
    fprintf('%d/%d\n', k, numNSpos);
    disp(' Reverberation Time:')
    for rt = 1:numReverbTime
        fprintf(' %d/%d\n', rt, numReverbTime);
        NS_IR(:, :, k, rt) = rir_generator(c, fs, r, obj.WFSposition(k, :), roomDim, beta(rt), numSamp);
    end
end

NS_RR = zeros(obj.numMicro, numFreqs, numNSpos, numReverbTime);
disp('FR NS')
for k = 1:numNSpos
    fprintf('%d/%d\n', k, numNSpos);
    disp(' Reverberation Time:')
    for rt = 1:numReverbTime
        NS_RR(:, :, k, rt) = DFT_slow(fs*NS_IR(:, :, k, rt).', fs, freqs).'; % (numFrequencies x numLoudspeakers)
    end
end

save([dataPathName, 'ImpulseResponsesNS_', ID, '.mat'], 'r', 'roomDim', 'numSamp', 'numNSpos', 'NS_IR', 'freqs', 'NS_RR')

%% Simulation
fprintf('Freqs:\n')
for rt = 1:numReverbTime
    for f = 1:numFreqs
        fprintf('%d/%d\n', f, numFreqs);
        obj.frequency = freqs(f);
        
        % Set up acoustic paths for the WFS array
        obj.domain= 'time';
        WFSacPathIR = permute(WFS_IR(:, :, :, rt), [1, 3, 2]);
        obj.setAcousticPaths('WFS', WFSacPathIR);
        
        obj.domain= 'frequency';
        WFSacPathFR = WFS_RR(:, f, :, rt);
        
        
        disp(' NS positions:')
        for ns = 1:numNSpos
            fprintf(' %d/%d\n', ns, numNSpos);
            obj.NSposition = NSpositions(ns, :);
            
            % Calculate the frequency response for the current frequency
            obj.domain = 'time';
            NSacPathIR = repmat(permute(NS_IR(:, :, ns, rt), [1, 3, 2]), [1, 2]);
            obj.setAcousticPaths('WFS', WFSacPathIR);
            
            obj.domain = 'frequency';
            
            
            % Simulate for time domain
            
            % Simulate for frequency domain
        end
        
    end
end
