%% Experiment 14

% Script used to generate the graphs for the section of the TFM report
% about the relation between acoustic path and distance to loudspeaker. The
% intention is to compare the acoustic paths measured in GTAC anechoic
% chamber with the ones generated by the rir_generator to find some
% similarities.

% It is a modification of Experiment13.m.

%% Preamble
pathSetUp;

imagesPath = 'C:\Users\Rubén\Google Drive\Telecomunicación\Máster 2º Curso 2015-2016\TFM MUIT\Documentos\TFM\Img\';

dataPathName = [globalPath, 'Data\'];
ID = datestr(now, 'yyyy-mm-dd_HH-MM-SS');

%% Simulation of different reflection coefficient (beta) values

%%% Simulation
if ~exist('obj', 'var') || ~isvalid(obj)
    obj = SimulationController;
    obj.WFSToolObj.fig.HandleVisibility = 'off';
end

% Generate WFS array positions
s = WFSToolSimple.generateScenario(96);
WFSposition = s.loudspeakersPosition;

% Constants
WFSfilterLength = 22050;
zPos = 1.65;
WFSarrayOffset = [0.46 2.21 zPos]; % [x, y, z] coordinates. Useful for generating acoustic path IR.
roomDim = [4.48, 9.13, 2.64];
fs = 44100;
c = 340;

% Microphone positions
% Rectangular grid
marginRatio = 0.6;
numPointsX = 5;
numPoinstY = 5;
extRectXmin = min(WFSposition(:, 1));
extRectXmax = max(WFSposition(:, 1));
extRectYmin = min(WFSposition(:, 2));
extRectYmax = max(WFSposition(:, 2));
octagonRectPos = [extRectXmin, extRectYmin, extRectXmax - extRectXmin, extRectYmax - extRectYmin];
gridXLength = octagonRectPos(3)*marginRatio;
gridYLength = octagonRectPos(4)*marginRatio;
centerX = (extRectXmax + extRectXmin)/2;
centerY = (extRectYmax + extRectYmin)/2;
gridMinX = centerX - gridXLength/2;
gridMaxX = centerX + gridXLength/2;
gridMinY = centerY - gridYLength/2;
gridMaxY = centerY + gridYLength/2;
xLim = [gridMinX, gridMaxX ]; yLim = [gridMinY, gridMaxY];
x = linspace(xLim(1), xLim(2), numPointsX);
y = linspace(yLim(1), yLim(2), numPoinstY);
z = 0;
[X, Y, Z] = ndgrid(x, y, z);
recPositions = [X(:), Y(:), Z(:)];

% Frequencies
freqs = 440; % 100:200:1000;

% Room characteristics and impulse response of chamber
beta = [0, 0.1, 0.2, 0.4, 0.6]; % Average reflection coefficient of the walls of the chamber
WFS_AcPath_previously_calculated = true;
NS_AcPath_previously_calculated = true;
appendFreeSpaceAcPaths = false;

% Irrelevant variables that are necessary in order to SetupParameterScript
% to work
amplitude = 1;
phase = 0;
freqFilters = {};
NSpositions = [0 0 0];

SetupParametersScript
AcousticPathCalculationScript


%% Fragment taken from Experiment2.m. Adapt it to our case.
% Evolution of field as a function of distance to loudspeakaer

numLoudspeakers = obj.numWFS;
distances = calcDistances(recPositions, obj.WFSposition);

% Fitting. Useful for later.
models = {'a/x'}; %{'exp1', 'exp2', 'power1', 'power2', 'a*exp(-b*x)+c'};
data = repmat(struct('x', [], 'y', []), numFreqs, numLoudspeakers, numReverbTime);

for f = 1:numFreqs
    for rt = 1:numReverbTime
        for indLoud = 1:numLoudspeakers
            data(f, indLoud, rt).x = distances(:, indLoud);
            data(f, indLoud, rt).y = abs(WFS_FR(:, f, indLoud, rt));
        end
    end
end
[params, gofs] = fitInterface( data, models );
as = zeros(size(params{1}));
as(:) = [params{1}.a];

data = repmat(struct('x', [], 'y', []), numFreqs, numReverbTime);
for f = 1:numFreqs
    for rt = 1:numReverbTime
        data(f, rt).x = distances(:);
        data(f, rt).y = abs(mergeAndPermute(WFS_FR(:, f, :, rt), {1:4}));
    end
end
[params, gofs] = fitInterface( data, models );
asGlob = zeros(size(params{1}));
asGlob(:) = [params{1}.a];

% Magnitude
%     % Specific Loudspeaker
% vecs = {1:numMicro, freqs, 1:numLoudspeakers+1, beta};
% freq = 440; indLoud = 1; beta_curr = 0.2;
% [~, repData] = filterArrayForRepresentation(vecs, abs(WFS_FR), 1, 'nonIndepDimValues', [freq, indLoud, beta_curr]);
% ax = axes(figure, 'NextPlot', 'Add');
% scatter(ax, distances(:, indLoud), repData)
% dVec = 0:0.05:max(distances(:, indLoud));
% [~, paramA] = filterArrayForRepresentation(vecs(2:end), as, [], 'nonIndepDimValues', [freq, indLoud, beta_curr]);
% plot(ax, dVec, paramA./dVec);
% ax.XLabel.String = 'Distance (m)';
% ax.YLim = [0, max(repData)];
% ax.YLabel.String = 'Field';
% legend(ax, {'Measured', 'Theoretical'});

    % Global magnitude
vecs = {1:numMicro, freqs, 1:numLoudspeakers, beta};
freq = 440; beta_curr = 0.6;
[repVectors, repData] = filterArrayForRepresentation(vecs, abs(WFS_FR), [1 3], 'nonIndepDimValues', [freq, beta_curr]);
ax = axes(figure, 'NextPlot', 'Add');
scatter(ax, distances(:), repData(:), '.')
[~, paramA] = filterArrayForRepresentation({freqs, beta}, asGlob, [], 'nonIndepDimValues', [freq, beta_curr]);
plot(ax, dVec, paramA./dVec);
ax.XLabel.String = 'Distance (m)';
ax.YLim = [0, max(repData(:))];
ax.YLabel.String = 'Field';

% Phase
phaseReal = angle(WFS_FR);

    % Specific Loudspeaker
freq = 440; indLoud = 1; beta_curr = 0.2;
[repVec, phaseLoud] = filterArrayForRepresentation(vecs, phaseReal, 1, 'nonIndepDimValues', [freq, indLoud, beta_curr]);
distLoud = distances(:, indLoud);

phaseTheoLoud = -2*pi*freq*distLoud/c;

ax = axes(figure);
scatter(ax, distLoud, rad2deg(wrapToPi(phaseLoud - phaseTheoLoud)), '.');
ax.YLim = [-180, 180];
ax.YTick = -180:60:180;
ax.YGrid = 'on';
ax.XLabel.String = 'Distance (m)';
ax.YLabel.String = 'Phase shift (º)';

    % Global Phase shift
[~, phaseRealGlob] = filterArrayForRepresentation(vecs, phaseReal, [1 3], 'nonIndepDimValues', [freq, beta_curr]);
phaseTheo = -2*pi*freq*distances/c;

ax = axes(figure);
scatter(ax, distances(:), rad2deg(wrapToPi(phaseRealGlob(:) - phaseTheo(:))), '.');
ax.YLim = [-180, 180];
ax.YTick = -180:60:180;
ax.YGrid = 'on';
ax.XLabel.String = 'Distance (m)';
ax.YLabel.String = 'Phase shift (º)';

%% Do the same with the GTAC measured acoustic paths
load([dataPathName, 'acousticPathsGTAC_440.mat']);
% [acousticPath, microphonePositions] = importImpulseResponseGTAC([0 440]);
distancesGTAC = calcDistances(microphonePositions, obj.WFSposition);

% Fitting. Useful for later.
models = {'a/x'}; %{'exp1', 'exp2', 'power1', 'power2', 'a*exp(-b*x)+c'};
data = struct('x', distancesGTAC(:), 'y', abs(acousticPath(:)));
[paramsGTAC, gofsGTAC] = fitInterface( data, models );
asGTAC = paramsGTAC{1}.a;

% Global magnitude
ax = axes(figure, 'NextPlot', 'Add');
scatter(ax, distancesGTAC(:), abs(acousticPath(:)), '.')
plot(ax, dVec, asGTAC./dVec);
ax.XLabel.String = 'Distance (m)';
ax.YLim = [0, max(repData(:))];
ax.YLabel.String = 'Field';

% Put both graphs in one
vecs = {1:numMicro, freqs, 1:numLoudspeakers, beta};
freq = 440; beta_curr = 0.6;
[~, acPathRIR] = filterArrayForRepresentation(vecs, abs(WFS_FR), [1 3], 'nonIndepDimValues', [freq, beta_curr]);

dVec = 0:0.05:max(distances(:, indLoud));

ax = axes(figure, 'NextPlot', 'Add');

scatter(ax, distancesGTAC(:), abs(acousticPath(:)), '.')
plot(ax, dVec, asGTAC./dVec);

scatter(ax, distances(:), acPathRIR(:), '.')
[~, paramA] = filterArrayForRepresentation({freqs, beta}, asGlob, [], 'nonIndepDimValues', [freq, beta_curr]);
plot(ax, dVec, paramA./dVec);

ax.XLabel.String = 'Distance (m)';
ax.XLim = [0, max(distances(:))];
ax.YLim = [0, max(repData(:))];
ax.YLabel.String = 'Field';

