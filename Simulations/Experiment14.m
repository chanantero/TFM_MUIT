%% Experiment 14

% Script used to generate the graphs for the section of the TFM report
% about the relation between acoustic path and distance to loudspeaker. The
% intention is to compare the acoustic paths measured in GTAC anechoic
% chamber with the ones generated by the rir_generator to find some
% similarities.

% It is a modification of Experiment13.m.

%% Preamble
pathSetUp;

imagesPath = 'C:\Users\Rubén\Google Drive\Telecomunicación\Máster 2º Curso 2015-2016\TFM MUIT\Documentos\TFM\Img\';

dataPathName = [globalPath, 'Data\'];
ID = datestr(now, 'yyyy-mm-dd_HH-MM-SS');

%% Simulation of different reflection coefficient (beta) values

%%% Simulation
if ~exist('obj', 'var') || ~isvalid(obj)
    obj = SimulationController;
    obj.WFSToolObj.fig.HandleVisibility = 'off';
end

% Generate WFS array positions
s = WFSToolSimple.generateScenario(96);
WFSposition = s.loudspeakersPosition;

% Constants
WFSfilterLength = 22050;
zPos = 1.65;
WFSarrayOffset = [0.46 2.21 zPos]; % [x, y, z] coordinates. Useful for generating acoustic path IR.
roomDim = [4.48, 9.13, 2.64];
fs = 44100;
c = 340;

% Microphone positions
% Rectangular grid
marginRatio = 0.6;
numPointsX = 5;
numPoinstY = 5;
extRectXmin = min(WFSposition(:, 1));
extRectXmax = max(WFSposition(:, 1));
extRectYmin = min(WFSposition(:, 2));
extRectYmax = max(WFSposition(:, 2));
octagonRectPos = [extRectXmin, extRectYmin, extRectXmax - extRectXmin, extRectYmax - extRectYmin];
gridXLength = octagonRectPos(3)*marginRatio;
gridYLength = octagonRectPos(4)*marginRatio;
centerX = (extRectXmax + extRectXmin)/2;
centerY = (extRectYmax + extRectYmin)/2;
gridMinX = centerX - gridXLength/2;
gridMaxX = centerX + gridXLength/2;
gridMinY = centerY - gridYLength/2;
gridMaxY = centerY + gridYLength/2;
xLim = [gridMinX, gridMaxX ]; yLim = [gridMinY, gridMaxY];
x = linspace(xLim(1), xLim(2), numPointsX);
y = linspace(yLim(1), yLim(2), numPoinstY);
z = 0;
[X, Y, Z] = ndgrid(x, y, z);
recPositions = [X(:), Y(:), Z(:)];

% Frequencies
freqs = 0:10:1000;

% Room characteristics and impulse response of chamber
beta = [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5]; % Average reflection coefficient of the walls of the chamber
WFS_AcPath_previously_calculated = true;
NS_AcPath_previously_calculated = true;
appendFreeSpaceAcPaths = false;

% Irrelevant variables that are necessary in order to SetupParameterScript
% to work
amplitude = 1;
phase = 0;
freqFilters = {};
NSpositions = [0 0 0];

SetupParametersScript
AcousticPathCalculationScript


%% Fragment taken from Experiment2.m. Adapt it to our case.
% Evolution of field as a function of distance to loudspeakaer

numLoudspeakers = numel(s);
microPos = obj.microPos;
numMicro = size(microPos, 1);

distances = zeros(numMicro, numLoudspeakers);
WFSfield = zeros(numMicro, numLoudspeakers);
NSfield = zeros(numMicro, numLoudspeakers);
for k = 1:numLoudspeakers
    distances(:, k) = sqrt(sum((microPos - repmat(obj.WFSposition(k, :), numMicro, 1)).^2, 2));
    WFSfield(:, k) = s(k).recWFScoef;
    NSfield(:, k) = s(k).recNScoef;
end

% Fitting. Useful for later.
models = {'a/x'}; %{'exp1', 'exp2', 'power1', 'power2', 'a*exp(-b*x)+c'};
data = repmat(struct('x', [], 'y', []), numLoudspeakers + 1, 1);
for indLoud = 1:numLoudspeakers
    data(indLoud).x = distances(:, indLoud);
    data(indLoud).y = abs(WFSfield(:, indLoud));
end
data(numLoudspeakers + 1).x = distances(:);
data(numLoudspeakers + 1).y = abs(WFSfield(:));
[params, gofs] = fitInterface( data, models );

% Magnitude
    % Specific Loudspeaker
ax = axes(figure, 'NextPlot', 'Add');
indLoud = 20;
a = abs(WFSfield(:, indLoud));
d = distances(:, indLoud);
dVec = 0:0.05:max(d);
% scatter(ax, distances(:, indLoud), params{1}(indLoud).a*abs(NSfield(:, indLoud)), '.')
plot(ax, dVec, params{1}(indLoud).a./dVec)
scatter(ax, distances(:, indLoud), abs(WFSfield(:, indLoud)), '.')
ax.YLim = [0 max(abs(WFSfield(:, indLoud)))];
ax.XLabel.String = 'Distance (m)';
ax.YLabel.String = 'Field';
legend(ax, {'Theoretical', 'Measured'});
printfig(ax.Parent, imagesPath, 'Experiment2_loud20_AmpByDist', 'eps');

    % Global magnitude
ax = axes(figure, 'NextPlot', 'Add');
% scatter(ax, distances(:), abs(NSfield(:)), '.')
scatter(ax, distances(:), abs(WFSfield(:)), '.')

% Phase
phaseReal = angle(WFSfield);
phaseTheo = -2*pi*obj.frequency/obj.WFSToolObj.c*distances; % It is the same as: phaseTheo = angle(NSfield);

    % Specific Loudspeaker
indLoud = 29;
phaseRealLoud = phaseReal(:, indLoud);
phaseTheoLoud = phaseTheo(:, indLoud);
distLoud = distances(:, indLoud);
% [distSort, indSort] = sort(dist);
% idealPhase = -2*pi*obj.frequency/obj.WFSToolObj.c*distSort;
% ax = axes(figure, 'NextPlot', 'Add');
% realPhase = idealPhase + wrapToPi(phase(indSort) - idealPhase);
% plot(ax, distSort, rad2deg(idealPhase))
% scatter(ax, distSort, rad2deg(realPhase), '.')
% ax.XLabel.String = 'Distance (m)';
% ax.YLabel.String = 'Phase (º)';
% legend(ax, {'Theoretical', 'Measured'});

    % Phase shift
ax = axes(figure);
scatter(ax, distLoud, rad2deg(wrapToPi(phaseLoud - phaseTheoLoud)), '.');
ax.YLim = [-180, 180];
ax.YTick = -180:60:180;
ax.YGrid = 'on';
ax.XLabel.String = 'Distance (m)';
ax.YLabel.String = 'Phase shift (º)';
% printfig(ax.Parent, imagesPath, 'Experiment2_loud20_PhaseByDist', 'eps');

    % Global phase

    % Global Phase shift
ax = axes(figure);
scatter(ax, distances(:), rad2deg(wrapToPi(phaseReal(:) - phaseTheo(:))), '.');
ax.YLim = [-180, 180];
ax.YTick = -180:60:180;
ax.YGrid = 'on';
ax.XLabel.String = 'Distance (m)';
ax.YLabel.String = 'Phase shift (º)';

     % % Other way
% ax = axes(figure, 'NextPlot', 'Add');
% phase = angle(WFSfield(:));
% dist = distances(:);
% [distSort, indSort] = sort(dist);
% idealPhase = -2*pi*obj.frequency/obj.WFSToolObj.c*distSort;
% realPhase = idealPhase + wrapToPi(phase(indSort) - idealPhase);
% plot(ax, distSort, rad2deg(idealPhase))
% scatter(ax, distSort, rad2deg(realPhase), '.')
% ax.XLabel.String = 'Distance (m)';
% ax.YLabel.String = 'Phase (º)';
% legend(ax, {'Theoretical', 'Measured'});


% Phase shift
phaseShift = wrapToPi(phaseReal - phaseTheo); % The same as: phaseShift = angle(WFSfield./NSfield);

[meanPhaseShift, ~, stdPhaseShift] = circularDistributionParameters(phaseShift);
meanPhaseShift = rad2deg(meanPhaseShift);
stdPhaseShift = rad2deg(stdPhaseShift);

ax = axes(figure);
plot(ax, 1:numScen, meanPhaseShift, 1:numScen, meanPhaseShift + stdPhaseShift, '--', 1:numScen, meanPhaseShift - stdPhaseShift, '--')
ax.XLabel.String = 'Loudspeakers';
ax.YLabel.String = 'Phase Shift (º)';

globalMean = mean(phaseShift(:));
globalStd = std(phaseShift(:));

axHist = axes(figure);
histogram(axHist, phaseShift)